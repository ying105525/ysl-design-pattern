package singleton;

/**
 * Created by Senliang-Ying on 2020/2/16.
 *
 * 懒汉式单例01 （非线程安全的）
 *
 * 饿汉式单例精髓就是延迟加载，当你需要的时候再创建这个类对象。
 *
 * 懒汉式设计模式，有一种叫法：延迟加载
 *
 *
 * 懒汉式单例模式步骤：
 * 		1：构造私有
 * 		2：定义私有静态成员变量，先不初始化
 * 		3：定义公开静态方法，获取本身对象
 * 			有对象就返回已有对象
 * 			没有对象，再去创建
 *
 * 线程安全问题，判断依据：
 * 		1：是否存在多线程	是
 * 		2：是否有共享数据	是
 * 		3：是否存在非原子性操作
 ** 并发编程的三大特性
 * 			** 原子性
 * 				*** 狭义上指的是CPU操作指令必须是原子操作
 * 				*** 广义上指的是字节码指令是原子操作
 * 				*** 如何保证原子性呢？加锁（synchronize、Lock）
 * 			** 有序性
 * 				*** 狭义上指的是CPU操作指令是有序执行的
 * 				*** 广义上指的是字节码指令是有序执行的
 * 				*** 指令重排序（JIT即时编译器的优化策略）
 * 					** happend-before六大原则
 * 					** 两行代码之后的操作，执行结果不存在影响，就可以发生指令重排序（JMM课程）
 *
 * 						int i =10;
 * 						boolean a = false;
 *
 * 						i ++ ; // 操作1
 * 						a = true; // 操作2
 *
 * 			** 可见性
 * 				*** 在多核（CPU）时代，内存的可见性是一个很常见的并发问题。
 * 				*** 可见性的解决需要使用到volatile关键字
 *
 * 		* 对象在JVM中的创建步骤	Student student = new Student();
 * 			** 1.new：开辟JVM堆中的内存空间
 * 			** 2.将内存空间初始化（指的就是对象的成员变量初始化为0值）
 * 			** 3.将内存空间地址（引用地址）赋值给引用类型的变量
 *
 * 			** 结论：在new对象的时候，JIT即时编译器会根据运行情况，对对象创建的过程进行指令重排序（132）
 *
 * 		* 线程执行代码的时候需要通过竞争CPU时间片去执行
 * 		* volatile关键字
 * 			* 作用一：禁止被它修饰的变量发生指令重排操作。是通过内存屏障去完成的禁止指令重排序。
 * 			* 作用二：简单理解是禁止CPU缓存使用，其实是被volatile关键字修饰的变量，在修改之前，都需要将最新CPU缓存中的数据刷新到主内存中。
 *
 */
public class LPerson01 {


    //  1.私有化构造函数
    private LPerson01(){}

    //  2. 定义私有静态成员变量 ，不初始化
    private static LPerson01 lPerson01;

    //  3.对外获取对象的接口，内部判断是否为空
    public LPerson01 lPerson01Factory(){
        if(lPerson01 == null){
            lPerson01 = new LPerson01();
        }
        return lPerson01;
    }

}
